package cn.hackedmc.apotheosis.module.impl.exploit.disabler;

import cn.hackedmc.apotheosis.Client;
import cn.hackedmc.apotheosis.component.impl.player.RotationComponent;
import cn.hackedmc.apotheosis.module.impl.combat.KillAura;
import cn.hackedmc.apotheosis.module.impl.exploit.Disabler;
import cn.hackedmc.apotheosis.newevent.Listener;
import cn.hackedmc.apotheosis.newevent.Priorities;
import cn.hackedmc.apotheosis.newevent.annotations.EventLink;
import cn.hackedmc.apotheosis.newevent.impl.motion.PostMotionEvent;
import cn.hackedmc.apotheosis.newevent.impl.other.WorldChangeEvent;
import cn.hackedmc.apotheosis.newevent.impl.packet.PacketReceiveEvent;
import cn.hackedmc.apotheosis.newevent.impl.packet.PacketSendEvent;
import cn.hackedmc.apotheosis.util.packet.PacketUtil;
import cn.hackedmc.apotheosis.value.Mode;
import cn.hackedmc.apotheosis.value.impl.BooleanValue;
import net.minecraft.network.Packet;
import net.minecraft.network.play.INetHandlerPlayClient;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.client.C07PacketPlayerDigging;
import net.minecraft.network.play.client.C08PacketPlayerBlockPlacement;
import net.minecraft.network.play.client.C0BPacketEntityAction;

import java.util.concurrent.LinkedBlockingQueue;

public class GrimACDisabler extends Mode<Disabler> {
    public GrimACDisabler(String name, Disabler parent) {
        super(name, parent);
    }
    public final BooleanValue post = new BooleanValue("Post", this, false);

    private final BooleanValue badPacketsF = new BooleanValue("Bad Packets F", this, false);
    private final BooleanValue badPacketsG = new BooleanValue("Bad Packets G", this, false);
    private final BooleanValue fastBreak = new BooleanValue("Fast Break", this, false);
    private final BooleanValue higherVersion = new BooleanValue("Move 1.17+", this, false);

    private boolean sprinting;
    private boolean sneaking;

    public LinkedBlockingQueue<Packet<INetHandlerPlayClient>> packets = new LinkedBlockingQueue<>();
    @Override
    public void onEnable() {
        reset();
    }

    @EventLink
    private final Listener<WorldChangeEvent> onWorldChange = event -> {
        release();
        reset();
    };

    @Override
    public void onDisable() {
        release();
    }

    @EventLink(value = Priorities.VERY_HIGH)
    private final Listener<PostMotionEvent> onMotionPost = event -> {
        release();
    };

    @EventLink
    private final Listener<PacketSendEvent> onPacketSend = event -> {
        Packet<?> packet = event.getPacket();
        if (packet instanceof C0BPacketEntityAction) {
            final C0BPacketEntityAction wrapped = (C0BPacketEntityAction) packet;

            if (badPacketsF.getValue()) {
                if (wrapped.getAction() == C0BPacketEntityAction.Action.START_SPRINTING) {
                    if (sprinting)
                        event.setCancelled();

                    sprinting = true;
                }

                if (wrapped.getAction() == C0BPacketEntityAction.Action.STOP_SPRINTING) {
                    if (!sprinting)
                        event.setCancelled();

                    sprinting = false;
                }
            }

            if (badPacketsG.getValue()) {
                if (wrapped.getAction() == C0BPacketEntityAction.Action.START_SNEAKING) {
                    if (sneaking)
                        event.setCancelled();

                    sneaking = true;
                }

                if (wrapped.getAction() == C0BPacketEntityAction.Action.STOP_SNEAKING) {
                    if (!sneaking)
                        event.setCancelled();

                    sneaking = false;
                }
            }
        }

        if (fastBreak.getValue()) {
            if (packet instanceof C07PacketPlayerDigging) {
                final C07PacketPlayerDigging wrapped = (C07PacketPlayerDigging) packet;

                if (wrapped.getStatus() == C07PacketPlayerDigging.Action.STOP_DESTROY_BLOCK) {
                    mc.getNetHandler().addToSendQueueUnregistered(new C07PacketPlayerDigging(C07PacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, wrapped.getPosition(), wrapped.getFacing()));
                }
            }
        }

        if (higherVersion.getValue() && packet instanceof C03PacketPlayer && !(packet instanceof C03PacketPlayer.C06PacketPlayerPosLook)) {
            final C03PacketPlayer wrapped = (C03PacketPlayer) packet;

            if (wrapped.moving) {
                mc.getNetHandler().addToSendQueueUnregistered(new C03PacketPlayer.C06PacketPlayerPosLook(
                        wrapped.x,
                        wrapped.y,
                        wrapped.z,
                        RotationComponent.rotations.x,
                        RotationComponent.rotations.y,
                        wrapped.onGround
                ));
            } else if (wrapped.rotating) {
                mc.getNetHandler().addToSendQueueUnregistered(new C03PacketPlayer.C06PacketPlayerPosLook(
                        mc.thePlayer.posX,
                        mc.thePlayer.posY,
                        mc.thePlayer.posZ,
                        wrapped.yaw,
                        wrapped.pitch,
                        wrapped.onGround
                ));
            } else {
                mc.getNetHandler().addToSendQueueUnregistered(new C03PacketPlayer.C06PacketPlayerPosLook(
                        mc.thePlayer.posX,
                        mc.thePlayer.posY,
                        mc.thePlayer.posZ,
                        RotationComponent.rotations.x,
                        RotationComponent.rotations.y,
                        wrapped.onGround
                ));
            }
        }
    };

    private void reset() {
        sprinting = false;
        sneaking = false;
        packets.clear();
    }

    private void release() {
        if (mc.getNetHandler() == null) return;

        while (!packets.isEmpty()) {
            Packet<INetHandlerPlayClient> packet = packets.poll();

            // 处理包前触发 PacketReceiveEvent
            PacketReceiveEvent packetReceiveEvent = new PacketReceiveEvent(packet);
            Client.INSTANCE.getEventBus().handle(packetReceiveEvent);

            if (packetReceiveEvent.isCancelled()) {
                continue;
            }

            // 处理包
            packet.processPacket(mc.getNetHandler());
        }
    }

}
