package cn.hackedmc.apotheosis.module.impl.exploit.disabler;

import cn.hackedmc.apotheosis.component.impl.player.BadPacketsComponent;
import cn.hackedmc.apotheosis.component.impl.player.BlinkComponent;
import cn.hackedmc.apotheosis.newevent.Listener;
import cn.hackedmc.apotheosis.newevent.annotations.EventLink;
import cn.hackedmc.apotheosis.newevent.impl.motion.PreMotionEvent;
import cn.hackedmc.apotheosis.newevent.impl.other.WorldChangeEvent;
import cn.hackedmc.apotheosis.newevent.impl.packet.PacketSendEvent;
import cn.hackedmc.apotheosis.newevent.impl.render.Render2DEvent;
import cn.hackedmc.apotheosis.module.impl.exploit.Disabler;
import cn.hackedmc.apotheosis.util.chat.ChatUtil;
import cn.hackedmc.apotheosis.value.Mode;
import cn.hackedmc.apotheosis.value.impl.BooleanValue;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.client.C0FPacketConfirmTransaction;
import util.time.StopWatch;

import java.util.*;

public class RiseBalanceDisabler extends Mode<Disabler> {

    private BooleanValue resetOnWorldChange = new BooleanValue("Reset On World Change", this, false);
    private BooleanValue forceLowTimer = new BooleanValue("Force low timer when Balance is below 0", this, false);
    private BooleanValue display = new BooleanValue("Display", this, false);
    private BooleanValue pulse = new BooleanValue("Pulse", this, false);
    private BooleanValue onlyWhenStill = new BooleanValue("Only Still", this, false);

    private double balance = 0;
    private long lastTime = -1;
    private final StopWatch stopWatch = new StopWatch();
    private final StopWatch lastSend = new StopWatch();
    private final Map<Long, C0FPacketConfirmTransaction> transactionMap = new LinkedHashMap<>();


    public RiseBalanceDisabler(String name, Disabler parent) {
        super(name, parent);
    }

    @Override
    public void onEnable() {
        this.reset();
    }

    @Override
    public void onDisable() {
        final Iterator<Map.Entry<Long, C0FPacketConfirmTransaction>> iterator = transactionMap.entrySet().iterator();

        while (iterator.hasNext())
            mc.getNetHandler().addToSendQueueUnregistered(iterator.next().getValue());

        transactionMap.clear();

        BlinkComponent.blinking = false;
    }

    @EventLink()
    public final Listener<PacketSendEvent> onPacketSend = event -> {
        Packet<?> packet = event.getPacket();

        if (packet instanceof C03PacketPlayer) {
            C03PacketPlayer c03PacketPlayer = ((C03PacketPlayer) packet);

            if (!c03PacketPlayer.getRotating() && !c03PacketPlayer.isMoving() && !BadPacketsComponent.bad() &&
                    (!onlyWhenStill.getValue() || (mc.thePlayer.posX == mc.thePlayer.lastTickPosX && mc.thePlayer.posY == mc.thePlayer.lastTickPosY && mc.thePlayer.posZ == mc.thePlayer.lastTickPosZ))) {
                event.setCancelled(true);
                lastTime = System.currentTimeMillis();
            } else {
                lastTime = -1;
                final Iterator<Map.Entry<Long, C0FPacketConfirmTransaction>> iterator = transactionMap.entrySet().iterator();
                if (mc.timer.timerSpeed == 1) {
                    while (iterator.hasNext())
                        mc.getNetHandler().addToSendQueueUnregistered(iterator.next().getValue());

                    transactionMap.clear();
                } else {
                    if (iterator.hasNext()) {
                        Map.Entry<Long, C0FPacketConfirmTransaction> data = iterator.next();
                        iterator.remove();

                        new Thread(() -> {
                            try {
                                Thread.sleep(Math.round(data.getKey() / mc.timer.timerSpeed));
                                mc.getNetHandler().addToSendQueueUnregistered(data.getValue());
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }).start();
                    }
                }
            }

            // We use this instead of an else because some other modules might cancel c03s
            if (!event.isCancelled() || BlinkComponent.blinking) {
                this.balance -= 50;
            }

            this.balance += stopWatch.getElapsedTime();
            this.stopWatch.reset();
        }

        if (packet instanceof C0FPacketConfirmTransaction) {
            if (lastTime != -1 || (!transactionMap.isEmpty() && mc.timer.timerSpeed != 1)) {
                event.setCancelled();
                transactionMap.put(System.currentTimeMillis() - lastTime, (C0FPacketConfirmTransaction) packet);
            }
        }
    };

    @EventLink()
    public final Listener<PreMotionEvent> onPreMotionEvent = event -> {
        if (mc.thePlayer.ticksExisted % 20 == 0 && this.display.getValue()) {
            ChatUtil.display("Balance: " + this.balance);
        }

        if (this.pulse.getValue() && mc.timer.timerSpeed > 1) {
            BlinkComponent.blinking = true;
            if (lastSend.finished(50 * 9)) {
                lastSend.reset();
                BlinkComponent.dispatch();
            }
        }
    };

    @EventLink()
    public final Listener<WorldChangeEvent> onWorldChange = event -> {
        if (this.resetOnWorldChange.getValue()) {
            this.reset();
        }
    };

    private void reset() {
        this.transactionMap.clear();
        this.lastTime = -1;
        this.balance = 0;
        this.stopWatch.reset();
    }

    @EventLink()
    public final Listener<Render2DEvent> onRender2D = event -> {
        if (this.forceLowTimer.getValue() && this.balance < 200) {
            mc.timer.timerSpeed = this.balance < 0 ? 0.5f : 1;
        }
    };
}